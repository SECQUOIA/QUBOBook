Traceback (most recent call last):
  File "/home/murraybj/CHE498/QUBOBook/.venv/lib/python3.10/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/murraybj/CHE498/QUBOBook/.venv/lib/python3.10/site-packages/nbclient/client.py", line 1314, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/home/murraybj/CHE498/QUBOBook/.venv/lib/python3.10/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
  File "/usr/lib/python3.10/asyncio/base_events.py", line 649, in run_until_complete
    return future.result()
  File "/home/murraybj/CHE498/QUBOBook/.venv/lib/python3.10/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/home/murraybj/CHE498/QUBOBook/.venv/lib/python3.10/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/murraybj/CHE498/QUBOBook/.venv/lib/python3.10/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
fig, ax = plt.subplots()
# Best of boot samples es computed via n_boot bootstrapping
# n_boot=500
boots = range(1,1000,1)
interest_sweeps = [min_sweep, default_sweeps, 10, 500]
approx_ratio = {}
approx_ratioci = {}

for schedul in schedules:
    approx_ratio[schedule] = {}
    approx_ratioci[schedule] = {}

# Gather instance names
instance = 42
for sweep in interest_sweeps:
    for schedule in schedules:
        if sweep in approx_ratio[schedule] and sweep in approx_ratioci[schedule]:
            pass
        else:
            min_energy = results['min_energy'][schedule]
            random_energy = results['random_energy'][schedule]

            pickle_name = str(instance) + "_" + schedule + "_" + str(sweep) + ".p"
            pickle_name = os.path.join(pickle_path, pickle_name)
            # If the instance data exists, load the data
            if os.path.exists(pickle_name) and not overwrite_pickles:
                # print(pickle_name)
                samples = pickle.load(open(pickle_name, "rb"))
                time_s = samples.info['timing']
            # If it does not exist, generate the data
            else:
                start = time.time()
                samples = simAnnSampler.sample(model_random, num_reads=total_reads, num_sweeps=sweep, beta_schedule_type=schedule)
                time_s = time.time() - start
                samples.info['timing'] = time_s
                pickle.dump(samples, open(pickle_name, "wb"))
            # Compute statistics
            energies=samples.data_vectors['energy']
            if min(energies) < min_energy:
                min_energy = min(energies)
                print("A better solution of " + str(min_energy) + " was found for sweep " + str(sweep))

            b = []
            bcs = []
            probs = []
            time_to_sol = []
            for boot in boots:
                boot_dist = []
                pr_dist = []
                for i in range(int(n_boot - boot + 1)):
                    resampler = np.random.randint(0, total_reads, boot)
                    sample_boot = energies.take(resampler, axis=0)
                    # Compute the best along that axis
                    boot_dist.append(min(sample_boot))   
                
                b.append(np.mean(boot_dist))
                # Confidence intervals from bootstrapping the best out of boot
                bnp = np.array(boot_dist)
                cilo = np.apply_along_axis(stats.scoreatpercentile, 0, bnp, 50.-ci/2.)
                ciup = np.apply_along_axis(stats.scoreatpercentile, 0, bnp, 50.+ci/2.)  
                bcs.append((cilo,ciup))

            approx_ratio[schedule][sweep] = [(random_energy - energy) / (random_energy - min_energy) for energy in b]
            approx_ratioci[schedule][sweep] = [tuple((random_energy - element) / (random_energy - min_energy) for element in energy) for energy in bcs]

        ax.plot([shot*sweep for shot in boots], approx_ratio[schedule][sweep], label=str(sweep) + ' sweeps')
        approx_ratio_bestci_np = np.stack(approx_ratioci[schedule][sweep], axis=0).T
        ax.fill_between([shot*sweep for shot in boots],approx_ratio_bestci_np[0],approx_ratio_bestci_np[1],alpha=0.25)
ax.set(xscale='log')
ax.set(ylim=[0.9,1.01])
ax.set(xlim=[1e2,1e4])
ax.set(xlabel='Total number of reads (equivalent to time)')
ax.set(ylabel='Approximation ratio = \n ' + '(best found - random sample) / (min energy - random sample)')
ax.set_title('Simulated annealing approximation ratio of Ising 42 N=100\n' +
          ' with varying schedule, ' + str(n_boot) + ' bootstrap re-samples, and sweeps')
plt.legend()

------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mKeyboardInterrupt[0m                         Traceback (most recent call last)
Cell [0;32mIn[31], line 51[0m
[1;32m     49[0m pr_dist [38;5;241m=[39m []
[1;32m     50[0m [38;5;28;01mfor[39;00m i [38;5;129;01min[39;00m [38;5;28mrange[39m([38;5;28mint[39m(n_boot [38;5;241m-[39m boot [38;5;241m+[39m [38;5;241m1[39m)):
[0;32m---> 51[0m     resampler [38;5;241m=[39m [43mnp[49m[38;5;241;43m.[39;49m[43mrandom[49m[38;5;241;43m.[39;49m[43mrandint[49m[43m([49m[38;5;241;43m0[39;49m[43m,[49m[43m [49m[43mtotal_reads[49m[43m,[49m[43m [49m[43mboot[49m[43m)[49m
[1;32m     52[0m     sample_boot [38;5;241m=[39m energies[38;5;241m.[39mtake(resampler, axis[38;5;241m=[39m[38;5;241m0[39m)
[1;32m     53[0m     [38;5;66;03m# Compute the best along that axis[39;00m

File [0;32mnumpy/random/mtrand.pyx:782[0m, in [0;36mnumpy.random.mtrand.RandomState.randint[0;34m()[0m

File [0;32mnumpy/random/_bounded_integers.pyx:1315[0m, in [0;36mnumpy.random._bounded_integers._rand_int64[0;34m()[0m

File [0;32m~/CHE498/QUBOBook/.venv/lib/python3.10/site-packages/numpy/core/fromnumeric.py:2979[0m, in [0;36mprod[0;34m(a, axis, dtype, out, keepdims, initial, where)[0m
[1;32m   2974[0m [38;5;28;01mdef[39;00m [38;5;21m_prod_dispatcher[39m(a, axis[38;5;241m=[39m[38;5;28;01mNone[39;00m, dtype[38;5;241m=[39m[38;5;28;01mNone[39;00m, out[38;5;241m=[39m[38;5;28;01mNone[39;00m, keepdims[38;5;241m=[39m[38;5;28;01mNone[39;00m,
[1;32m   2975[0m                      initial[38;5;241m=[39m[38;5;28;01mNone[39;00m, where[38;5;241m=[39m[38;5;28;01mNone[39;00m):
[1;32m   2976[0m     [38;5;28;01mreturn[39;00m (a, out)
[0;32m-> 2979[0m [38;5;129m@array_function_dispatch[39m(_prod_dispatcher)
[1;32m   2980[0m [38;5;28;01mdef[39;00m [38;5;21mprod[39m(a, axis[38;5;241m=[39m[38;5;28;01mNone[39;00m, dtype[38;5;241m=[39m[38;5;28;01mNone[39;00m, out[38;5;241m=[39m[38;5;28;01mNone[39;00m, keepdims[38;5;241m=[39mnp[38;5;241m.[39m_NoValue,
[1;32m   2981[0m          initial[38;5;241m=[39mnp[38;5;241m.[39m_NoValue, where[38;5;241m=[39mnp[38;5;241m.[39m_NoValue):
[1;32m   2982[0m [38;5;250m    [39m[38;5;124;03m"""[39;00m
[1;32m   2983[0m [38;5;124;03m    Return the product of array elements over a given axis.[39;00m
[1;32m   2984[0m 
[0;32m   (...)[0m
[1;32m   3098[0m [38;5;124;03m    10[39;00m
[1;32m   3099[0m [38;5;124;03m    """[39;00m
[1;32m   3100[0m     [38;5;28;01mreturn[39;00m _wrapreduction(a, np[38;5;241m.[39mmultiply, [38;5;124m'[39m[38;5;124mprod[39m[38;5;124m'[39m, axis, dtype, out,
[1;32m   3101[0m                           keepdims[38;5;241m=[39mkeepdims, initial[38;5;241m=[39minitial, where[38;5;241m=[39mwhere)

[0;31mKeyboardInterrupt[0m: 

